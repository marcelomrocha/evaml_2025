import sys
import os
import copy # lib para a geracao de copias de objetos

import xml.etree.ElementTree as ET
import xmlschema # xmlschema validation

from rich import print
from rich.console import Console
from rich.progress import Progress, BarColumn

import time

import config

console = Console()

# XMLSchema validation.
# Este trecho de codigo valida o xml.
# Podem ocorrer dois tipos de erro: (1) xml mal-formado e (2) erro de valida√ß√£o.

# checking if flags were used
# if (len(sys.argv)) == 2: # no flags
#   print("\nWARNING!!! No flags were used. Please, see the options below:")
#   print("---------------------------------------------------------------------------------------------------")
#   print("| FLAG\t\t| DEFINITION                                                                      |")
#   print("---------------------------------------------------------------------------------------------------")
#   print('| -c or -C\t| "Compiles" the EvaML script, outputting an XML file to run in the Eva simulator.|')
#   print("| -s or -S\t| Saves/Inserts the JSON file generated by the parser into the robot's database.  |")
#   print("| -r or -R\t| Makes the EVA robot run the script immediately.                                 |")
#   print("---------------------------------------------------------------------------------------------------\n")
#   exit(1) # finish the execution



# Fun√ß√£o de valida√ß√£o do script EvaML. #############################################
def evaml_validator(evaml_file):
  global tree
  try:
    valido = True
    val = schema.iter_errors(evaml_file)
    for idx, validation_error in enumerate(val, start=1):
      print(f'  [{idx}] path: [red b]{validation_error.path}[/] | reason: {validation_error.reason}')
      valido = False
  except Exception as e:
    print(val)
    print(e)
    return None
  else:
    if valido == True:
      return ET.parse(evaml_file) #
    else:
      return None


###############################################################################
# (Parsing) Processamento do comando (loop)                                              #
###############################################################################
def process_loop(script_node):
    global id_loop_number
    for i in range(len(script_node)):
        if len(script_node[i]) != 0: process_loop(script_node[i])
        if script_node[i].tag == "loop":
            id_loop_number += 1 # Var utilizada na cria√ß√£o de nomes de algumas vari√°veis autom√°ticas. Comeca com 1.
            loop_copy = copy.deepcopy(script_node[i]) # Copia o elemento  <loop>.
            c = ET.Element("counter") # Cria o <counter> que inicializa a var de itera√ß√£o com o valor zero.
            if script_node[i].get("id") != None: # Caso o <loop> seja alvo de um goto.
                id_loop = script_node[i].attrib["id"] 
                c.attrib["id"] = id_loop
            if script_node[i].get("var") != None: 
                var_loop = script_node[i].attrib["var"] 
                c.attrib["var"] = var_loop
            else: # Caso o usu√°rio n√£o defina uma vari√°vel para a itera√ß√£o, a variavel default "ITERATION_VAR...." ser√° criada.
                var_loop = "ITERATION_VAR" + str(id_loop_number) 

            times_loop = script_node[i].attrib["times"] 
            c.attrib["var"] = var_loop 
            c.attrib["op"] = "=" 
            c.attrib["value"] = "1"  # Inicializa a variavel contadora com zero

            script_node.remove(script_node[i]) # Remove o elemento <loop> pois n√£o √© mais necess√°rio (temos a sua c√≥pia em )
            script_node.insert(i, c)  # Adiciona o <counter> que inicializa a variavel de itera√ß√£o

            s = ET.Element("switch")  # Cria o elemento <switch>
            s.attrib["id"] = "LOOP_ID" + str(id_loop_number) + "_" + var_loop  # Prefixo padrao do id automatico gerado para o loop _LOOP_ID_
            s.attrib["var"] = var_loop 
            script_node.insert(i + 1, s)  # Adiciona o <switch>, com seus filhos, ao elemento script

            cs = ET.Element("case") # Cria o elemento <case>
            cs.attrib["op"] = "lte" 
            cs.attrib["value"] = times_loop 
            cs.extend(loop_copy)  # O extend adiciona apenas os filhos de loop

            c = ET.Element("counter")  # Cria o <counter> que incrementa a vari√°vel de itera√ß√£o
            c.attrib["var"] = var_loop
            c.attrib["op"] = "+"
            c.attrib["value"] = "1"
            cs.append(c)

            g = ET.Element("goto")  # Cria o <goto> que faz o loop acontecer
            g.attrib["target"] = "LOOP_ID" + str(id_loop_number) + "_" + var_loop  # prefixo padrao do id automatico gerado para o loop _LOOP_ID_

            cs.append(g)  # Adiciona o <goto> (que causa a repeti√ß√£o) ao final do <case> 

            s.insert(0, cs)  # Insere o <case> com o corpo dentro do <switch>

            process_loop(script_node) # O processamento de um loop muda a estrutura inicial do scriptnode e precisa ser revisitada


xmlschema_file = os.getcwd() + "/" + config.ROBOT_PACKAGE_FOLDER + "/xml_schema/evaml_schema.xsd"
schema = xmlschema.XMLSchema(xmlschema_file)



script_file = sys.argv[1]

console.clear()
console.rule("\nü§ñ [yellow reverse b]  Parsing the script: " + script_file.split("/")[-1] + "  [/] ü§ñ")
print()

# Validating the script. #########################################################################
with Progress(
    "[bold blue]{task.description}",
    BarColumn(),
    "[progress.percentage]{task.percentage:>3.0f}%",
) as progress:
    task = progress.add_task("[b white reverse] STEP 1. Validating the script     ", total=30)
    
    for i in range(30):
        progress.update(task, advance=1)
        time.sleep(0.02)
        
xml_file_ok = evaml_validator(script_file)

if not xml_file_ok:
  print("\n[b white on red blink] VALIDATION ERROR üëÜ [/]: The script [b cyan]" + script_file.split("/")[-1] + " [/][b white]failed[/]. Please, [b white]check[/] the info above.\n")
  exit(1)
else:
  print(" ‚úÖ [b green reverse] The script was validated! [/]\n")


# Parsing (Loop processing)
with Progress(
    "[bold blue]{task.description}",
    BarColumn(),
    "[progress.percentage]{task.percentage:>3.0f}%",
) as progress:
    task = progress.add_task("[b white reverse] STEP 2. Parsing the script file   ", total=30)
    
    for i in range(30):
        progress.update(task, advance=1)
        time.sleep(0.02)

id_loop_number = 0  # Id usado na cria√ß√£o dos ids dos loops.
root = xml_file_ok.getroot() # Evaml root node.
script_node = root.find("script")
process_loop(script_node)

print(" ‚úÖ [b green reverse] Done! [/]\n")


# Gera o arquivo com os loops expandidos (caso existam).
with Progress(
    "[bold blue]{task.description}",
    BarColumn(),
    "[progress.percentage]{task.percentage:>3.0f}%",
) as progress:
    task = progress.add_task("[b white reverse] STEP 3. Generating the EvaML file [/]", total=30)
    
    for i in range(30):
        progress.update(task, advance=1)
        time.sleep(0.02)

print(" ‚úÖ [b green reverse] The file " +  script_file.split('/')[-1][:-4] + "_evaml.xml" + " was created! [/]\n\n")

xml_file_ok.write(script_file[:-4] + "_evaml.xml", "UTF-8")



